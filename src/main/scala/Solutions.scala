

object Solutions {
  def main(args: Array[String]): Unit = {
    //    println("abc".last)
    //    val s = "abc"
    //    println(s.substring(0, s.length-1))
    //    println(isMatch("aab", "c*a**b")) // false
    //    println(isMatch("aa", "*a")) // false
    //    println(isMatch("aaa", "ab*a")) //false
    //    println(isMatch("aaa", "ab*a*c*a")) // true
    //    println(isMatch("aasdfasdfasdfasdfas", "aasdf.*asdf.*asdf.*asdf.*s")) // true
    //    println(isMatch("", "c*c*")) // true
    //    println(maxArea(Array(1, 8, 6, 2, 5, 4, 8, 3, 7)))
    //    println(letterCombinations("234"))
    //    val node1 = new ListNode(1)
    //    val node2 = new ListNode(2)
    //    val node3 = new ListNode(3)
    //    val node4 = new ListNode(4)
    //    val node5 = new ListNode(5)
    //    node1.next = node2
    //    node3.next = node4
    //    node4.next = node5
    //    var n = removeNthFromEnd(node1, 3)
    //    var n = mergeKLists(Array(node1, node3, node5))
    //    while (n != null) {
    //      println(n.x + " -> ")
    //      n = n.next
    //    }

    //    val arr = Array(-1, 0, 1, 2, -1, -4)
    //    val s = threeSum(arr)
    //    println(s)
    //    println(generateParenthesis(4))

    //        println(longestValidParentheses2("((())))()())))(((()()(())))((()(())()((()))())())())()())))))))(((()(())(()))(()()(()()((()))()(())(()(())))))()(())(()()(((()(()()))))((()()))))))()((()())()()))((())()((((()))()()()((()())))())((())))))))(()()((((((()))(((((((()()))((())()(()())()()()(()())(()())(())))()()))))()(((())(())(()())()))()(()))(())((()))))(())))()))((()((()(())(()()()()()))(())())()))))()(()(((())))()()()(((()((()))(()((((((())((()))(()(())(()))(())())))()()))))())(()((()()())()))((((()(()))()()))(()())))((()))(()((((()(())(())()((()))(()))())))(((()(())))((())()(()(((())))())())()()()())((()()))))))(()))(())()(((()))()()((()))(()))(((()))))))))(()(())())(()((())(()()))((())))(()())((((())))(()(()))())(((()(()((()(())((())())(()))(())))()()(())((()()))((()()((()()())())()))())()))())()))())(()(()))(()))()(())))((((())()())()()())((()())(()())(()()))()(())(())))))()()()((()(())(((()(())()()))(()()((()(((()))))))))(((()((()()((()(((((())((()((()((((((((())()))())((())((()((()(()((())(((()(()))())))))))))))))()((()(())())))()(()))(((()))())()(((()))))((()(())(()())(((()(((()((((())()))))(())((()(((((()((()(()()()()((()((((((((((((())()(()))()()(()())()(()(((()((()(()()()())))((())()))())()()))())(((()(())))))()()()(((())))((()(()(((())(())(()((((()(((()(())(((((())()))())())()()(()())((((()(())))((()())))))))))()(()(())))))))()))()())))((())(()()()()()()()(())(()())))))())((()()))))()))))((())((()(((()))))(((()()))()(()((()()())()))(((()(()((())(()(()(()()))()((()(())))()((())))))(())()(())()))((())(((((()))()())(())))((((()((())())(())))(())))))((())())())((((()((())))()()((()()()))()())())(()())(((()))()()))))(()(())(()))()())(()())(()))(((((((()(()))())()())()())((()(((((()())(((())))()())))(()(()(())()((())()))(())))())()))((((()))())((()))(())))))(()))))))(()))))(())))())()()())()()(())()()(((((()))(((()()))()(()((((()(()(()(())))())))())(()()())()(()))())(()()))(()()((()()))))))(())((()()))(())))())())(())((((()))))()))()))()()()))))((((()((())(()))(()()))(())()())(()())))(()(()(())((()())()((())(()))()))()))))((())))(())(()))()()()()()))((())(((()(())))(((((((()(()))(()))())()((()))(()(())((()((()((())))()()((())))))((((())()())(()()(((()()((()))()()((())))(((()())((((()(())())))())()()()(())()))))))()()((()))())(()(((()()))((())))())())())((((()(((()(())())()())((()((()(()((())()(()))()((())))()(()))))(((()))())())(()((()))))()()(((((()))())))(()(()(())((((())())))((()()())(((((((()(()(()))(())))))()))(()(((((())()))((()()()()((()))()(()()()()))(()))))())())()))()(()()(((())((()))(()())))((()()(((())())))))))(())))((()(()(((())((((()))))(()()()))))(((((((())(()(()))(()(())((())(()(()(()(()())(())()(())(()()(()(()))())(())()()(((()())(())(()(((()()(())()((((()()))())(((()(((((()())()(())))()))))(()(()()(()(()()(((()))()))((()())))()(()(())))))))())((((()()))(()))))()((()))(()))())()))()))))(()(())()()()))(((((()))()())())(()())())))()())))))()()()())))))(())(((()))((())((()()))))()((((()(()(()))))(()(())(((())(()()(((()(())()())(()()(()(()())))()())))(((()()((()())()()((()))()))(((()((((()(((()(((()(()())((()))))()(()())(())()(()(((())((()))(())()(())()(()(())()))())()))()())(()))))()))))((()()()((()(()()(())))())(())()(()()))))))))()((()))((((())))())))((()()()(()(()((((()((()))()()((())((())(()))))(())())(((()()(()))))))(()()))()))((()(()(())()))(((())()))(())(()((((()((()()()))()()))(()()(())())((((((())(())((()())()(()())))()))())(()()(()(()()()(()()()()))(()(()()())())((()()()(((()((()())()()((()()(()((()())()())()((()))(()((()())))))))(())((((())(((((())(((())(()))(((()((()()())()((()(()))()()()(()((((())))(())())))((())))(()(((((()()()((())((((((((()()((((())))())())())))))))(((()())(((()))())))()))((())())())))))))))(()()(((())))))(())()()))((())()))(()(()))((()(()((((()(()(((()))))()))(()(()))())())()()(((())())(((()))))(((()())))()(()())()())()))())())(()()(((()()))(())(((()((())((((())))))((()))))(()((()(())))()(())((()(())((()(()())())))()))))(())())(()())()()()((())))((()()))()()()((((()())))))()))))()))())()((()(())()()(())(((()((()))(()(()()))(()))()))))))))))))(()()))(((())((()(((()()()(()())((((()(()()()))())))())(()())))(()((((()))((()()())(((()))()())(()(()((()(()))))(())()()((()())((()(()(()))((()((()())(((()(((((()()()))(()()(()(((()(()())()()()))((()(()())))())(()(()))(())()())))()()()))()())(()(((((()))()()((((()()()()))()()(()((()))(()))))))))))()))()(()((((((())(()))()((())))(((((())))))(()))))()()(()()()(((((()))()())()((((()()))()(())())))(((()((())))))))))(()()()((()))(()())((())))()()((()())))()()(()))))))))()(((()(()))()())((((((())))(((()(()())())))(())())())()()((((()(()(((())(()()(((((()))(()(())()))))))()))()())))()()(()))(((()))()())))((())(((()()))((((((())))(((())()()(()((()))())(()((()()(((())())()))()()())())(()()((((((((())))()(((())(()))))()()())()(())))(((((()())(((())()()))))()((())())(())()(()(()()((()))()(()(((()))))()()())(())()()()(((()((()()()(()())())(())()(((((()())(())()((((()()()))()((())()((()(()(((()(()))()())())()())()(()()(()(((()))()(())(()())(())((())()((()()())(()))))()(()()))))((())()()((()((()()(()((()()())(())))))())))()))))(((((()(()())(()))((()))()(()())())())))()(()()(()((())))))()()))((())((((()))))())((()))())((())((()(()((()))()()()))()((((((())((((((()((((((((()))(()(((()(((((((((())(())())()())))))))())())))()))(()))))()(()))(())))()()()((()()))(())(()))(()()(()())))()(()()()()())))(())((((()))(((((())(()(((((())((()((((()))(((((()))(()())()))))())()))()(()()))((((()))()())(())))()((())))(((((()()((()()((()))))()((())())()))(((((((((()((())((((())()())))(())())()))())))())()))()(()()(()))(()()()((())((()))())))()(()())()(((((((()))))(()()()((()(())))())()))((())())(()(()(())()()())))))(()()()))())()))()())(((())(())))()(())())))()((()(()(())()()()((()))()))((())((((()((((((()()()))()))())())))))()(())(()())))()(((()())(((())))((())()()))((())())()()(()()())()))())(((()((()(((()())(()(())(((())))()))))))())()((((((()))))))()(()))()))())))())((((())(())()(())()))()))((((((((()()(())())((((())))((((()(())()()(())()))())()))(((()((()))()(((((()()()))))(()(()())))(((()(((()(())())((((())(()((()((()(()()(()()))()))()()))()))))))())()(())())))(((())))((()))((()(())())((())))((()))()))(((()))))(()())()())())()())))())))(())))(())())()((()())()()))((()()())(((((()())))())))()()()((((((())())()((())()))(()))()(()())()())(())()())((()((())(())()()()()((())(()())()()((())))()(((()(()(((((()(())))()(()))()(()))()))())()))()())()(()))))()()())(((())((()((())(()(()))()((()))))))(())(()(())())()()((())((())((((())))))(()()())(()()())(())())(((()()(())(())))()()))(())))))())(())()(((())())))((()(((())))(()((())()))()))((()()())()(((((())((((())))(())()()((()()(()()))(()((()))((())())))))))()())))())())((()(()()()()()))))()))((())(((((()())(()))((())))((()(())))))))))(((())(()(())(()(())((()((()))()((())())()())()((()(())())()(((()()((()(()())))))())((())(((()())(((()(()((())((()(((())(()()((((((()))())))())(()(()(()()())())((()))((())(())(())())))()(()())()))())(())((((())()((())))))(()()((())(((((()))()()))()()())(()(((()))())()()()))(((()()))(()(()((())(())))()()((((()()))()(())()())()()()()()(()()))(((())(((()()()((((((((((()()()(((()))))))())))()(((((((()((((((((()))()(((())())())())((((((()()))(()))()))))(())()())))())(()))(((())()()()((()()((())(()))((()(()())))()(()((()((())()()()()(())()()((())())())()()))()()))))((()()((())(((())(())())))((())())())(()))))())))))()((()(()(()))))()))((((())((())())(()))))()((()))(())((()()))()()((())(())())))(())))))()()(()())((()(())(((()((())))()())))()))()))))(())()(()))((()()()()))(())))(()()(())(((()(((()()))()((()))())()))(()(()))())))))))()((()(()))(((())())(())(()))(())(()((()))))))(()())(()()()(((()(((((()))((()))))(()))(())())(((()(()())(()()()()))())(()((()(()))()))())))(((()(()))))()))(()()((())())(()()())((()))(())))()()))(())))())))(()((())((()))((()))))())()()()((((((())((())()))(()))(())(())())))()())()((())))((()()())(()))(((()))())())))(())(())())()())()))((((()()()()))(())))((((())))(())(()((((()))())()))))))()()()))())))()((())))))((())())))()()(()()(()(()()()())((((())))(())(((())(()(()((((())(()()()(()(()((())(())(()())((((()((()((((((()((((())(((()())()((((()((())()(()(()(()((()()()(()(()())(((()(())(()(())(())(()))()((((((((()()(())))(()()(((())()(()(((((()())((()(())()())(((()(()(())()((((((((())()((()()((((())(((()(()((()((((()((((()(()(())())()(((()()))))))(()(((())()(((()())))((()))))(()()))))(()))))))((())())((())))()()()(()((()))()))()))()()()()()))(((((((()((()))((())()(()(()))()((((((((((((()(())))))(()())))()(()()(()(()()))))(((((()()((())()))())()()()))(())())()())()()((()()(()(()()(()))))))()()))(()()((()))))()((()()()())))(((()(((()()(())(())(()(((())(()((()(()))(()()((())()(()()())()))))))(()()((())((()())))(())(()))()(()))(()))()))()(())()(()())))(()))(()()(((()))))())))))((())())))))()()()))(()))((()())())()()))(((())((()((())()(()))()((()))()(())))))))()()())())))(()()(())(()))(())))))()(()))(()()))))))))((((()()()()()))(()))((()((())))(()())(((()()()(())))))()))()())())(()()()))))))((()())))((())))(())()((()))()(()())())))))(((()()(()(())()())(((((()))((()(())(())))))))()()))))))((()((((()()))()))(()()))(()()(())))))(((()()))(()())))(())()((()((()(((()()()()((()())())(()(((((((()((((())(()((((()()(())))))(()())))))(()())))())(())))((()(()))(()())(((())))((((())))))((()))()(((((((())())())((())))))))(()))))))))()((()()())((())))(())))((()(((()(())(())))()()()()))(())(()(())()())(())))()())((()((()((()()((())())))(()((())()()))()))((()()(()))(((((((()))((())((())((())()()((((((((()())()()()))(()()(((()(())()))()))()))()()(()(((((()))))((())(((()))()((((((((()()()()(()))()(()))()(())))))))()((((()()((()(())()((()))((()()(()()))))))))))(())(()))()()((((())))()((())(()((()((()(())()))()()((((()))))()))())))))())(((()()))()))()(()))(()))()((()((((((())())))()))()((())(()(())))))))()))(()()()())())()))((()))(()((()((()())))))((((())()()())(())())()((()((()())()())()(()))))((()())))()))()()))))()((())))())(()))()))(()((())(()))))()()))(()()((((()()))(((()()())(()(()(((()))())))((((()())()()()(())()()()((()))))((()()(()()))()())))(((((()(())())))))(()))))())))(())())()))))((()))))))(((())(((())()(((())))(()))()())(((()(()(((()))))()(()()(())())))))())())()()((())))()(())((()))((())(()())(()()()(()()())((())())))))((()(()())()()))))(()()(()()()(()()))((((((()))(()())(())(())())((())(()(()))((()()(()))))()))()(())))())))())(()((())))((())(()()()(()))((()((((((()())()()))))()))((()((())()))()((((()()()(((())())))()()()())())())(()())()))()(())(())()))())((()(((((()))(())(((((()))(()())(()(()(())()((()(()(()))()(()))))()(((())(()((((((()))(()(((()()())()())((()())))((()((()())()((((((())()))(()))))(()()()()))())())((((((((())((((()()()))(())()()))(()(()()(()(()))))(()))(()()()(())()()(())(()))())((()()((()(()))()))))())((()())())(((((()(()()))((()()()))()()(()(()(((()())(((((((((()))()())(()(()(())(((((()()))))(()())(()())())(())))))((()))())(((()((((()))()))(()(()(((()()(()(((()()))(())))((((()(()()))))((((()()())()))())()))))((())((((((())()()))()))()(((()((())(()((((()())())((((((((((()(((((()())()()(()))))))()((((())())(((()()((((()()())()(((((())))()))(())())(((()(((())()))()()()()(())))(()(((()(()))())))()(((()()()()()(()(((()(((()))()(())(())()()))()((()))))))()(((((()(()()((())(())((())))()(()())(())))())((())(()(()()(((())((()()(()()((()))))())))()(()))()))))))())())))((((((()())))(())(()))()()))()(())))))))((()))(()()()()))()())()()()()))()()())))))))((())(())))(()))(())((()())))(()(((()))((((())())))(())((())())))))(((()())(())()(())))((()()()((()(()))()))(())))((()(()()((()()()))((()))((()))()))(()())()()(((((((((()(()))()())()((())((((((((()(())()(((()((())()((((((((()))())))(()((()((())())())((()()())))(()(()((((((()))))((((())))((()()(())()())()()())(())(((()(()()(())(((())((((())()()(()()(((())()(())((()(()(((()(()())))()))((()()())(())))))(()(()))()))()(()))))(()((()))()())(())(())(()))((()())()))())()())((((()))))())())(((()))(((()()((()((())(())()()))))(((()((((()(((((((((())()()()(())((()(()()(()()(()()(())()())(((((()))))()(())(((()((((()())(()(((()))))()))())((((()()((()(()))))((())(())(()(()))()()(((()))(((((((((()())))((())()(()(((((((()))))))()()(())(((()(()())()()))((()()))((((()(())())))((()())))))()))))))))()()(((())())((()))())((())((()()))())((((((((())((()((())())))))()()))))))()()(())))))()))()()(((()))))(())((((()()()()))((()((((()()(())(((((()())()))))))())())()((((((((((()))()))((()))(())())(()(()(())((()()(()((())(())((((())(()()(()((()((()(((((()(()()((((())(())())(()()())()())((()(())()(())()))))") )

    //    println(longestValidParentheses2(""))
    //        val arr = Array(5, 4, 7, 5, 3, 2) // 5,5,2,3,4,7
    //        val arr = Array(1, 2, 3) // 1, 3, 2
    //    val arr = Array(1, 3, 2) // 2, 1, 3
    //    val arr = Array(2, 1, 3) // 2,3,1
    //    val arr = Array(2, 2, 7, 5, 4, 3, 2, 2, 1)
    //    println("before: " + arr.mkString(","))
    //    nextPermutation(arr)
    //    println("after: " + arr.mkString(","))
    //    println(isValid(""))
    //    println(search(Array(4, 5, 6, 0, 1, 2, 3), 2))
    //    println(searchRange(Array(2, 2), 1).mkString(" "))
    //    println(combinationSum(Array(2, 3, 6, 7), 7))
    //    println(trap(Array(0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1)))
    //        println(permute(Array(1, 2, 3)))
    //    val t = Array.ofDim[Int](3, 3)
    //    t(0)(0) = 1
    //    t(0)(1) = 2
    //    t(0)(2) = 3
    //    t(1)(0) = 4
    //    t(1)(1) = 5
    //    t(1)(2) = 6
    //    t(2)(0) = 7
    //    t(2)(1) = 8
    //    t(2)(2) = 9
    //    rotate(t)
    //    for (i <- 0 until t.length) {
    //      println(t(i).mkString(" "))
    //
    //    }
    //    println(groupAnagrams(Array("eat", "tea", "tan", "ate", "nat", "bat")))
    //    println(maxSubArray(Array(-2, 1, -3, 4, -1, 2, 1, -5, 4)))
    //    println(canJump(Array(1))) // true
    //    println(canJump(Array(0))) // true
    //    println(canJump(Array(2, 0))) // true
    //    println(canJump(Array(3, 2, 1, 0, 4))) // false
    //    println(canJump(Array(1, 2))) // true
    //    println(canJump(Array(3, 2, 1, 0, 4))) // false
    //    println(canJump(Array(0, 2, 3))) // false
    //    println(canJump(Array(2, 0, 0))) // true
    //[[1,3],[2,6],[8,10],[15,18]]
    //    merge(Array(Array(1,3), Array(2,6), Array(8,10), Array(15,18)))
    //    val t = merge(Array(Array(2, 3), Array(4, 5), Array(6, 7), Array(8, 9), Array(1, 10)))
    //    for (a <- t) {
    //      println(a.mkString(" "))
    //    }
    //    println(uniquePaths(3, 7))
    //    println(minPathSum(Array(Array(1,3,1), Array(1,5,1), Array(4,2,1))))
    //    println(climbStairs(3))
    //    println(minDistance("horse", "ros"))
    //    val arr =Array(1,0)
    //    sortColors(arr)
    //    println(arr.mkString(" "))
    //    minWindow("ADOBECODEBANC", "ABC")
    //    subsets(Array(1, 2, 3))
    //    println(minWindow("ADOBECODEBANC", "ABC"))
    //    println(exist(Array(Array('A', 'B', 'C', 'E'), Array('S', 'F', 'C', 'S'), Array('A', 'D', 'E', 'E')), "SEE"))
    //    println(largestRectangleArea(Array(2, 1, 5, 5, 2, 3)))
    //    println(maximalRectangle(Array(Array('1', '0', '1', '0', '0'), Array('1', '0', '1', '1', '1'), Array('1', '1', '1', '1', '1'), Array('1', '0', '0', '1', '0'))))
    //    val list: List[String] = List("a", "b", "a")
    //    //为列表预添加元素
    //    println("A" +: list)
    //    //在列表开头添加元素
    //    println("c" :: list)
    //    //在列表开头添加指定列表的元素
    //    println(List("d", "e") ::: list)
    //    //复制添加元素后列表
    //    println(list :+ "1")

    val A = new TreeNode(1)
    val B = new TreeNode(2)
    val C = new TreeNode(5)
    val F = new TreeNode(3)
    val G = new TreeNode(4)
    val H = new TreeNode(6)
    A.left = B
    A.right = C
    B.left = F
    B.right = G
    C.right = H

    //
    //    println(inorderTraversal(A))
    //    println(numTrees2(19))
    //    println(isValidBST(A))
    //    buildTree(Array(4,1,2,3), Array(1,2,3,4))
    flatten(A)


  }

  /*
1. 两数之和
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。



示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
 */
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    for (i <- 0 until nums.length; j <- i + 1 until nums.length) {
      if (nums(i) + nums(j) == target) {
        return Array(i, j)
      }
    }
    Array[Int]()
  }

  class ListNode(_x: Int = 0, _next: ListNode = null) {
    var next: ListNode = _next
    var x: Int = _x
  }

  /*
  2. 两数相加
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
   */
  def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {
    var node1 = l1
    var node2 = l2
    var retNode: ListNode = null
    var curNode: ListNode = null
    var carry: Int = 0

    while (node1 != null || node2 != null) {
      if (retNode == null) {
        curNode = new ListNode
        retNode = curNode
      } else {
        curNode.next = new ListNode()
        curNode = curNode.next
      }

      val x1 = if (node1 == null) 0 else node1.x
      val x2 = if (node2 == null) 0 else node2.x
      val sum = x1 + x2 + carry
      if (sum / 10 > 0) {
        carry = sum / 10
        curNode.x = sum % 10
      } else {
        carry = 0
        curNode.x = sum
      }
      node1 = if (node1 == null) null else node1.next
      node2 = if (node2 == null) null else node2.next
    }
    if (carry > 0) {
      curNode.next = new ListNode(carry)
    }
    retNode
  }

  /*
  3. 无重复字符的最长子串
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
   */
  def lengthOfLongestSubstring(s: String): Int = {
    if (s.length == 1)
      return 1
    var latestLen = 0
    import scala.util.control.Breaks
    val loop = new Breaks
    for (i <- 0 until s.length) {
      loop.breakable {
        for (j <- i + latestLen until s.length) {
          val curStr = s.substring(i, j + 1)
          if (curStr.length > latestLen && curStr.length == curStr.distinct.length) {
            latestLen = curStr.length
          } else {
            loop.break()
          }
        }
      }
    }
    latestLen
  }

  /*
  4. 寻找两个正序数组的中位数
给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。

进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？



示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
示例 2：

输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
示例 3：

输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
示例 4：

输入：nums1 = [], nums2 = [1]
输出：1.00000
示例 5：

输入：nums1 = [2], nums2 = []
输出：2.00000


提示：

nums1.length == m
nums2.length == n
0 <= m <= 1000
0 <= n <= 1000
1 <= m + n <= 2000
-106 <= nums1[i], nums2[i] <= 106

   */
  def findMedianSortedArrays(nums1: Array[Int], nums2: Array[Int]): Double = {
    val len = nums1.length + nums2.length
    val intArr: Array[Int] = new Array[Int](len)
    var i1: Int = 0
    var i2: Int = 0
    for (j <- 0 until intArr.length) {
      val num1: Int = if (i1 < nums1.length) nums1(i1) else Int.MaxValue
      val num2: Int = if (i2 < nums2.length) nums2(i2) else Int.MaxValue
      if (num1 < num2) {
        intArr(j) = num1
        i1 += 1
      } else {
        intArr(j) = num2
        i2 += 1
      }
    }

    if (len % 2 == 1) {
      intArr(len / 2)
    } else {
      val m = len / 2
      (intArr(m - 1) + intArr(m)) / 2.0
    }
  }

  /*
  5. 最长回文子串
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"
   */
  def longestPalindrome(s: String): String = {
    var latestLength = 0
    var latestStr = ""

    for (i <- 0 until s.length) {
      for (j <- i + latestLength until s.length) {
        val curStr = s.substring(i, j + 1)
        if (isPalindrome(curStr)) {
          if (curStr.length > latestLength) {
            latestStr = curStr
            latestLength = curStr.length
          }
        }
      }
    }
    latestStr
  }

  def isPalindrome(s: String): Boolean = {
    for (i <- 0 until s.length) {
      if (i >= s.length - i - 1) {
        return true
      }
      if (s.charAt(i) != s.charAt(s.length - i - 1)) {
        return false
      }
    }
    false
  }

  /*
  10. 正则表达式匹配
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
示例 1:

输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
示例 2:

输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
示例 3:

输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
示例 4:

输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
示例 5:

输入:
s = "mississippi"
p = "mis*is*p*."
输出: false

   */
  def isMatch(s: String, p: String): Boolean = {
    if (s == p || p == ".*" || (p == "." && s.length == 1) || (s.isEmpty && (p.length == 2 && p.last == '*')) || s + "*" == p) {
      return true
    }
    if (p.isEmpty || (s.length == 1 && p.length == 1)) {
      return false
    } else if (s.isEmpty) {
      if (p.last == '*' && p.length > 1) {
        return isMatch(s, p.substring(0, p.length - 2))
      } else {
        return false
      }
    }
    val pl = p.last
    val sl = s.last

    if (sl == pl || pl == '.') {
      isMatch(s.substring(0, s.length - 1), p.substring(0, p.length - 1))
    } else if (pl == '*') {
      val preChar: Char = p.charAt(p.length - 2)
      // 当P为*时，S可能匹配一次，匹配0次，匹配多次
      // isMatch(s, p.substring(0, p.length - 2)) 匹配0次
      // isMatch(s.substring(0, s.length-1), p.substring(0, p.length-2)) 匹配1次
      // isMatch(s.substring(0, s.length - 1), p) 匹配多次
      if (preChar == sl || preChar == '.') {
        isMatch(s, p.substring(0, p.length - 2)) || isMatch(s.substring(0, s.length - 1), p.substring(0, p.length - 2)) || isMatch(s.substring(0, s.length - 1), p)
      } else {
        isMatch(s, p.substring(0, p.length - 2))
      }
    }
    else {
      false
    }
  }

  /*
  给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。

 



图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

 

示例：

输入：[1,8,6,2,5,4,8,3,7]
输出：49

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/container-with-most-water
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
   */
  def maxArea(height: Array[Int]): Int = {
    var head = 0
    var tail = height.length - 1
    var maxA = 0
    while (head < tail) {
      if (height(head) < height(tail)) {
        maxA = Math.max(height(head) * (tail - head), maxA)
        head += 1
      } else {
        maxA = Math.max(height(tail) * (tail - head), maxA)
        tail -= 1
      }
    }
    maxA
  }

  /*
  15. 三数之和
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。



示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
0 = -4
1 = -1
2 = -1
3 = 0
4 = 1
5 = 2

   */
  def threeSum(nums: Array[Int]): List[List[Int]] = {
    import scala.collection.mutable.ListBuffer
    import scala.util.control.Breaks
    val buffer: ListBuffer[List[Int]] = new ListBuffer[List[Int]]()
    val newNums = nums.sorted
    val loop = new Breaks
    for (i <- 0 until newNums.length) {
      if (i == 0 || newNums(i) != newNums(i - 1)) {
        for (j <- i + 1 until newNums.length) {
          if (j == (i + 1) || newNums(j) != newNums(j - 1)) {
            loop.breakable {
              for (k <- Range(newNums.length - 1, j, -1)) {
                val temp = newNums(i) + newNums(j) + newNums(k)
                if (temp < 0) {
                  loop.break()
                }
                if (temp == 0) {
                  buffer.append(List(newNums(i), newNums(j), newNums(k)))
                  loop.break()
                }
              }
            }
          }
        }
      }
    }
    buffer.toList
  }

  /*
  17. 电话号码的字母组合
  给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

  给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。



  示例:

  输入："23"
  输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
  说明:
  尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。
   */
  def letterCombinations(digits: String): List[String] = {
    import scala.collection.mutable.ListBuffer
    val maps = Map[Char, Array[String]](
      '1' -> Array[String]("!", "@", "#"), '2' -> Array[String]("a", "b", "c"), '3' -> Array[String]("d", "e", "f"),
      '4' -> Array[String]("g", "h", "i"), '5' -> Array[String]("j", "k", "l"), '6' -> Array[String]("m", "n", "o"),
      '7' -> Array[String]("p", "q", "r", "s"), '8' -> Array[String]("t", "u", "v"), '9' -> Array[String]("w", "x", "y", "z")
    )

    if (digits.isEmpty) return List[String]()
    val buffer: ListBuffer[Array[String]] = new ListBuffer[Array[String]]()

    for (c <- digits) {
      buffer.append(maps(c))
    }

    buffer.reduce((A, B) => {
      for (a <- A; b <- B) yield {
        a + b
      }
    }).toList
  }

  /*
  19. 删除链表的倒数第N个节点
  给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

  示例：

  给定一个链表: 1->2->3->4->5, 和 n = 2.

  当删除了倒数第二个节点后，链表变为 1->2->3->5.
  说明：

  给定的 n 保证是有效的。

  进阶：

  你能尝试使用一趟扫描实现吗？
   */
  def removeNthFromEnd(head: ListNode, n: Int): ListNode = {
    import scala.collection.mutable.ListBuffer
    var node = head
    val buffer: ListBuffer[ListNode] = new ListBuffer[ListNode]()

    while (node != null) {
      buffer.append(node)
      node = node.next
    }
    if (buffer.size == 1 && n == 1) {
      null
    } else if (buffer.size == 2) {
      if (n == 2) {
        buffer(0).next = null
        buffer(1)
      } else {
        buffer(0).next = null
        buffer(0)
      }
    } else {
      if (n == 1) {
        buffer(buffer.size - 2).next = null
      } else if (n == buffer.size) {
        head.next = null
        return buffer(1)
      } else {
        val preNode = buffer(buffer.size - n - 1)
        val nextNode = buffer(buffer.size - n + 1)
        preNode.next = nextNode
      }
      head
    }
  }

  /*
 20. 有效的括号
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

示例 1:

输入: "()"
输出: true
示例 2:

输入: "()[]{}"
输出: true
示例 3:

输入: "(]"
输出: false
示例 4:

输入: "([)]"
输出: false
示例 5:

输入: "{[]}"
输出: true
   */

  def isValid(s: String): Boolean = {
    if (s.length % 2 == 1) {
      return false
    }
    import scala.collection.mutable
    val map = Map((')', '('), (']', '['), ('}', '{'))
    val stack = mutable.Stack[Char]()
    for (c <- s) {
      if (stack.isEmpty) {
        if (map.keySet.contains(c)) {
          return false
        }
        stack.push(c)
      } else {
        if (stack.top == map.getOrElse(c, ' ')) {
          stack.pop()
        } else {
          stack.push(c)
        }
      }
    }
    stack.isEmpty
  }

  /*
  21. 合并两个有序链表
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。



示例：

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
   */
  def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
    var node1 = l1
    var node2 = l2
    var retNode: ListNode = null
    var retCurNode: ListNode = null

    if (node1 == null) {
      node2
    } else if (node2 == null) {
      node1
    } else {
      while (node1 != null && node2 != null) {
        if (retNode == null) {
          retNode = new ListNode()
          retCurNode = retNode
        } else {
          retCurNode.next = new ListNode()
          retCurNode = retCurNode.next
        }
        if (node1.x < node2.x) {
          retCurNode.x = node1.x
          node1 = node1.next
        } else {
          retCurNode.x = node2.x
          node2 = node2.next
        }
      }
      if (node1 != null)
        retCurNode.next = node1
      if (node2 != null)
        retCurNode.next = node2
      retNode
    }
  }

  /*
  22. 括号生成
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。



示例：

输入：n = 3
输出：[
       "((()))",
       "(()())",
       "(())()",
       "()(())",
       "()()()"
     ]
   */
  def generateParenthesis(n: Int): List[String] = {
    if (n == 0) {
      List[String]()
    } else {
      import scala.collection.mutable.ListBuffer
      val arr = new Array[ListBuffer[String]](n)
      arr(0) = ListBuffer("()")
      for (i <- 1 until n) {
        val buffer = new ListBuffer[String]()
        buffer.append(arr(i - 1)(0) + "()")
        val preList = arr(i - 1)
        for (str <- preList) {
          for (j <- 0 until str.length) {
            if (str.charAt(j) == ')') {
              var temp = str.substring(0, j) + "()" + str.substring(j)
              if (!buffer.contains(temp)) {
                buffer.append(temp)
              }
            }
          }
        }
        arr(i) = buffer
      }
      arr(n - 1).toList
    }
  }

  /*
  23. 合并K个升序链表
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。



示例 1：

输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
示例 2：

输入：lists = []
输出：[]
示例 3：

输入：lists = [[]]
输出：[]


提示：

k == lists.length
0 <= k <= 10^4
0 <= lists[i].length <= 500
-10^4 <= lists[i][j] <= 10^4
lists[i] 按 升序 排列
lists[i].length 的总和不超过 10^4
   */
  def mergeKLists(lists: Array[ListNode]): ListNode = {
    if (lists.isEmpty || (lists.length == 1 && lists(0) == null))
      return null
    lists.reduce(mergeTwoLists)
  }

  /*
  31. 下一个排列
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

   */
  def nextPermutation(nums: Array[Int]): Unit = {
    if (nums.isEmpty)
      return
    for (i <- Range(nums.length - 1, -1, -1); if (i - 1) >= 0) {
      if (nums(i - 1) < nums(i)) {
        if (i == nums.length - 1) {
          val temp = nums(i - 1)
          nums(i - 1) = nums(i)
          nums(i) = temp
          return
        }
        for (j <- i until nums.length) {
          if (j == nums.length - 1 || nums(i - 1) >= nums(j + 1)) {
            val temp = nums(i - 1)
            nums(i - 1) = nums(j)
            nums(j) = temp
            // 调换顺序后正序排序
            var mh = i
            var mt = nums.length - 1
            while (mh < mt) {
              val t = nums(mh)
              nums(mh) = nums(mt)
              nums(mt) = t
              mh += 1
              mt -= 1
            }
            return
          }
        }
      }
    }
    var head = 0
    var tail = nums.length - 1
    while (head < tail) {
      val temp = nums(head)
      nums(head) = nums(tail)
      nums(tail) = temp
      head += 1
      tail -= 1
    }
  }

  /*
  32. 最长有效括号
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:

输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
示例 2:

输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
   */
  // 动态规划法 ，推荐使用
  // 动态转移方程： dp(i) = dp(i-1) + dp(i-di(i-1)-1-1) + 2
  // 该方程的使用条件： 当dp(i)为 ')' 时，判断 dp(i-dp(i-1)-1)的位置是否为'('
  // 同时还需要考虑dp(i-dp(i-1)-1-1 前的最长有效子串
  def longestValidParentheses(s: String): Int = {
    if (s.isEmpty)
      return 0
    val dp: Array[Int] = new Array[Int](s.length)
    for (i <- 1 until dp.length) {
      if (s.charAt(i) == ')') {
        val t = i - dp(i - 1) - 1
        if (t >= 0 && s.charAt(t) == '(') {
          if (t - 1 >= 0) {
            dp(i) = dp(i - 1) + 2 + dp(t - 1)
          } else {
            dp(i) = dp(i - 1) + 2
          }
        }
      }
    }
    dp.max
  }

  // 最传统的方法，效率极差，非常不推荐使用
  def longestValidParentheses2(s: String): Int = {
    import scala.util.control.Breaks
    var maxValid = 0
    val loop = new Breaks
    for (i <- 0 until s.length; if (s.charAt(i) == '(')) {
      if (maxValid >= s.length - i) {
        return maxValid
      }
      loop.breakable {
        for (j <- Range(s.length, i, -1); if (s.charAt(j - 1) == ')' && (j - i) % 2 == 0)) {
          if (maxValid < j - i) {
            if (isValid(s.substring(i, j))) {
              maxValid = if (maxValid < j - i - 1) j - i else maxValid
              loop.break()
            }
          } else {
            loop.break()
          }
        }
      }
    }
    maxValid
  }

  /*
  33. 搜索旋转排序数组
给你一个升序排列的整数数组 nums ，和一个整数 target 。

假设按照升序排序的数组在预先未知的某个点上进行了旋转。（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。

请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。


示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
示例 2：

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
示例 3：

输入：nums = [1], target = 0
输出：-1


提示：

1 <= nums.length <= 5000
-10^4 <= nums[i] <= 10^4
nums 中的每个值都 独一无二
nums 肯定会在某个点上旋转
-10^4 <= target <= 10^
   */
  def search(nums: Array[Int], target: Int): Int = {
    val len = nums.length
    if (len == 0) {
      return -1
    } else if (len == 1) {
      return if (nums(0) == target) 0 else -1
    } else {
      var head = 0
      var tail = len - 1
      while (head <= tail) {
        val mid = (head + tail) / 2
        if (nums(mid) == target) {
          return mid
        }
        if (nums(0) <= nums(mid)) {
          if (nums(0) <= target && target < nums(mid)) {
            tail = mid - 1
          } else {
            head = mid + 1
          }
        } else {
          if (nums(mid) < target && target <= nums(len - 1)) {
            head = mid + 1
          } else {
            tail = mid - 1
          }
        }
      }
      -1
    }
  }

  /*
  34. 在排序数组中查找元素的第一个和最后一个位置
给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 O(log n) 级别。

如果数组中不存在目标值，返回 [-1, -1]。

示例 1:

输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
示例 2:

输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
   */
  def searchRange(nums: Array[Int], target: Int): Array[Int] = {
    val len = nums.length
    if (len == 0)
      return Array(-1, -1)
    if (len == 1) {
      return if (nums(0) == target) Array(0, 0) else Array(-1, -1)
    }
    if (target < nums(0) || target > nums(len - 1)) {
      return Array(-1, -1)
    }
    var head = 0
    var tail = len - 1
    while (head <= tail) {
      val mid = (head + tail) / 2
      if (nums(mid) < target) {
        head = mid + 1
      }

      if (nums(mid) > target) {
        tail = mid - 1
      }

      if (nums(head) < target) {
        head += 1
      } else if (nums(tail) > target) {
        tail -= 1
      } else {
        if (target == nums(head) && target == nums(tail)) {
          return Array(head, tail)
        }
      }
    }
    Array(-1, -1)
  }

  /*
  39. 组合总和
给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。
示例 1：

输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
示例 2：

输入：candidates = [2,3,5], target = 8,
所求解集为：
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]


提示：

1 <= candidates.length <= 30
1 <= candidates[i] <= 200
candidate 中的每个元素都是独一无二的。
1 <= target <= 500
   */

  import scala.collection.mutable.ListBuffer

  def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
    val buffer: ListBuffer[List[Int]] = new ListBuffer[List[Int]]()
    dfs(candidates, target, List(), 0, buffer)
    buffer.toList
  }

  def dfs(candidates: Array[Int], target: Int, combine: List[Int], idx: Int, buffer: ListBuffer[List[Int]]) {
    // 选 idx元素
    val temp = target - candidates(idx)
    if (temp == 0) {
      buffer.append(combine.::(candidates(idx)))
    } else if (temp > 0) {
      dfs(candidates, temp, combine.::(candidates(idx)), idx, buffer)
    }
    if (idx + 1 < candidates.length) {
      dfs(candidates, target, combine, idx + 1, buffer)
    }
  }

  /*
  42. 接雨水
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。



上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。

示例:

输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
   */
  def trap(height: Array[Int]): Int = {
    if (height.isEmpty)
      return 0
    val len = height.length
    val leftMaxArr: Array[Int] = new Array[Int](len)
    val rightMaxArr: Array[Int] = new Array[Int](len)

    leftMaxArr(0) = height(0)
    rightMaxArr(len - 1) = height(len - 1)

    for (i <- 1 until len) {
      leftMaxArr(i) = Math.max(leftMaxArr(i - 1), height(i))
      rightMaxArr(len - i - 1) = Math.max(height(len - i - 1), rightMaxArr(len - i))
    }

    var sum = 0
    for (i <- 0 until len) {
      sum += Math.min(leftMaxArr(i), rightMaxArr(i)) - height(i)
    }

    sum
  }

  /*
    46. 全排列
  给定一个 没有重复 数字的序列，返回其所有可能的全排列。

  示例:

  输入: [1,2,3]
  输出:
  [
    [1,2,3],
    [1,3,2],
    [2,1,3],
    [2,3,1],
    [3,1,2],
    [3,2,1]
  ]
     */
  def permute(nums: Array[Int]): List[List[Int]] = {
    val buffer: ListBuffer[List[Int]] = new ListBuffer[List[Int]]()
    val len = nums.length
    if (len == 0) {
      return List[List[Int]]()
    }
    val list: ListBuffer[Int] = new ListBuffer[Int]()
    val used: Array[Boolean] = new Array[Boolean](len)

    dfs(nums, 0, list, used, buffer)
    buffer.toList
  }

  def dfs(nums: Array[Int], depth: Int, list: ListBuffer[Int], used: Array[Boolean], buffer: ListBuffer[List[Int]]): Unit = {
    if (depth == nums.length) {
      buffer.append(list.toList)
      return
    }
    for (i <- 0 until used.length) {
      if (!used(i)) {
        used(i) = true
        list.append(nums(i))
        dfs(nums, depth + 1, list, used, buffer)
        list.remove(list.length - 1)
        used(i) = false
      }
    }
  }

  /*
  48. 旋转图像
给定一个 n × n 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

说明：

你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

示例 1:

给定 matrix =
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
示例 2:

给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
],

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
   */
  def rotate(matrix: Array[Array[Int]]): Unit = {
    val len = matrix.length - 1
    for (i <- 0 until (len + 2) / 2) {
      for (j <- 0 until (len + 1) / 2) {
        val temp = matrix(i)(j)
        matrix(i)(j) = matrix(len - j)(i)
        matrix(len - j)(i) = matrix(len - i)(len - j)
        matrix(len - i)(len - j) = matrix(j)(len - i)
        matrix(j)(len - i) = temp
      }
    }
  }

  /*
  49. 字母异位词分组
给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

示例:

输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
说明：

所有输入均为小写字母。
不考虑答案输出的顺序。
   */
  def groupAnagrams(strs: Array[String]): List[List[String]] = {
    val len = strs.length
    if (len == 0) {
      return List[List[String]]()
    }
    import scala.collection.mutable
    import scala.collection.mutable.ListBuffer
    val buffer: ListBuffer[List[String]] = new ListBuffer[List[String]]()
    val map: mutable.Map[String, List[String]] = mutable.Map[String, List[String]]()

    for (str <- strs) {
      val temp = str.sorted
      if (map.contains(temp)) {
        map.put(temp, map.get(temp).get.::(str))
      } else {
        map.put(temp, List(str))
      }
    }
    map.values.map(buffer.append(_))
    buffer.toList
  }

  /*
  53. 最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
   */
  def maxSubArray(nums: Array[Int]): Int = {
    if (nums.isEmpty)
      return 0
    val arr: Array[Int] = new Array[Int](nums.length)
    arr(0) = nums(0)
    var maxStrs = nums(0)
    for (i <- 1 until arr.length) {
      arr(i) = Math.max(arr(i - 1) + nums(i), nums(i))
      maxStrs = if (maxStrs < arr(i)) arr(i) else maxStrs
    }
    maxStrs
  }

  /*
  55. 跳跃游戏
 给定一个非负整数数组，你最初位于数组的第一个位置。

 数组中的每个元素代表你在该位置可以跳跃的最大长度。

 判断你是否能够到达最后一个位置。

 示例 1:

 输入: [2,3,1,1,4]
 输出: true
 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
 示例 2:

 输入: [3,2,1,0,4]
 输出: false
 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
   */
  def canJump(nums: Array[Int]): Boolean = {
    if (nums.length <= 1) {
      return true
    }
    if (nums(0) == 0) {
      return false
    }
    val arr: Array[Int] = new Array[Int](nums.length)
    arr(0) = nums(0)
    var maxIdx = nums(0)
    for (i <- 0 until nums.length - 1) {
      arr(i) = i + nums(i)
      maxIdx = if (maxIdx < arr(i)) arr(i) else maxIdx
      if (nums(i) == 0 && maxIdx <= i)
        return false
      if (arr(i) >= nums.length - 1) {
        return true
      }
    }
    false
  }

  /*
  56. 合并区间
给出一个区间的集合，请合并所有重叠的区间。



示例 1:

输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2:

输入: intervals = [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。



提示：

intervals[i][0] <= intervals[i][1]
   */
  def merge(intervals: Array[Array[Int]]): Array[Array[Int]] = {
    import scala.collection.mutable.ListBuffer
    import scala.util.control.Breaks
    val buffer: ListBuffer[Array[Int]] = new ListBuffer[Array[Int]]()
    val loop = new Breaks
    val ccc = intervals.sortWith((A, B) => A(0) < B(0))
    for (arr <- ccc) {
      if (buffer.isEmpty) {
        buffer.append(arr)
      } else {
        loop.breakable {
          for (t <- buffer) {
            if ((arr(0) >= t(0) && arr(0) <= t(1)) || (arr(1) >= t(0) && arr(1) <= t(1)) || (arr(0) < t(0) && arr(1) > t(1))) {
              t(0) = Math.min(t(0), arr(0))
              t(1) = Math.max(t(1), arr(1))
              loop.break()
            }
          }
          buffer.append(arr)
        }
      }
    }
    buffer.toArray
  }

  /*
  62. 不同路径
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？



例如，上图是一个7 x 3 的网格。有多少可能的路径？



示例 1:

输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
示例 2:

输入: m = 7, n = 3
输出: 28
   */
  def uniquePaths(m: Int, n: Int): Int = {
    val dp = Array.ofDim[Int](m, n)
    for (i <- 0 until m) {
      dp(i)(0) = 1
    }

    for (j <- 0 until n) {
      dp(0)(j) = 1
    }
    for (i <- 1 until m; j <- 1 until n) {
      dp(i)(j) = dp(i - 1)(j) + dp(i)(j - 1)
    }
    dp(m - 1)(n - 1)
  }

  /*
  64. 最小路径和
 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

 说明：每次只能向下或者向右移动一步。

 示例:

 输入:
 [
   [1,3,1],
   [1,5,1],
   [4,2,1]
 ]
 输出: 7
 解释: 因为路径 1→3→1→1→1 的总和最小。
   */
  def minPathSum(grid: Array[Array[Int]]): Int = {
    val row = grid.length
    val cel = grid(0).length
    val dp = Array.ofDim[Int](row, cel)
    dp(0)(0) = grid(0)(0)
    for (i <- 1 until row) {
      dp(i)(0) = dp(i - 1)(0) + grid(i)(0)
    }
    for (j <- 1 until cel) {
      dp(0)(j) = dp(0)(j - 1) + grid(0)(j)
    }
    for (i <- 1 until row; j <- 1 until cel) {
      dp(i)(j) = Math.min(dp(i - 1)(j), dp(i)(j - 1)) + grid(i)(j)
    }
    dp(row - 1)(cel - 1)
  }

  /*
  70. 爬楼梯
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
   */
  def climbStairs(n: Int): Int = {
    if (n <= 2)
      return n
    val dp = new Array[Int](n)
    dp(0) = 1
    dp(1) = 2
    for (i <- 2 until n) {
      dp(i) = dp(i - 1) + dp(i - 2)
    }
    dp(n - 1)
  }

  /*
  72. 编辑距离
给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符


示例 1：

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
示例 2：

输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
   */
  def minDistance(word1: String, word2: String): Int = {
    val m = word1.length
    val n = word2.length
    val dp = Array.ofDim[Int](m + 1, n + 1)
    for (i <- 0 to m) {
      dp(i)(0) = i
    }
    for (j <- 0 to n) {
      dp(0)(j) = j
    }
    for (i <- 1 to m; j <- 1 to n) {
      if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
        dp(i)(j) = dp(i - 1)(j - 1)
      } else {
        val A = dp(i - 1)(j) // 在第二个字符串中添加一个字符，使dp(i)(j)个字符串相同，将其抵消
        val B = dp(i)(j - 1) // 在第一个字符串中添加一个字符，使dp(i)(j)个字符串相同，将其抵消
        val C = dp(i - 1)(j - 1) // 在第一个字符串中替换一个字符，使dp(i)(j)个字符串相同，将其抵消
        dp(i)(j) = Math.min(A, Math.min(B, C)) + 1
      }
    }
    dp(m)(n)
  }

  /*
  75. 颜色分类
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:
不能使用代码库中的排序函数来解决这道题。

示例:

输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
进阶：

一个直观的解决方案是使用计数排序的两趟扫描算法。
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
你能想出一个仅使用常数空间的一趟扫描算法吗？
   */
  def sortColors(nums: Array[Int]): Unit = {
    var p0 = 0
    var p1 = 0
    for (i <- 0 until nums.length) {
      if (nums(i) == 0) {
        nums(i) = nums(p0)
        nums(p0) = 0
        if (p0 < p1) {
          val temp = nums(p1)
          nums(p1) = nums(i)
          nums(i) = temp
        }
        p0 += 1
        p1 += 1
      } else if (nums(i) == 1) {
        nums(i) = nums(p1)
        nums(p1) = 1
        p1 += 1
      }
    }
  }


  /*
    76. 最小覆盖子串
  给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。



  示例：

  输入：S = "ADOBECODEBANC", T = "ABC"
  输出："BANC"


  提示：

  如果 S 中不存这样的子串，则返回空字符串 ""。
  如果 S 中存在这样的子串，我们保证它是唯一的答案。
     */
  def minWindow(s: String, t: String): String = {
    val sLen = s.length
    val tLen = t.length

    var left, right = 0

    val tArr = new Array[Int](128)
    val sArr = new Array[Int](128)
    for (c <- t) {
      tArr(c) += 1
    }

    var minLen = Int.MaxValue
    var minStr = ""
    var distance = 0 // 通过distance来匹配s子串与t串匹配

    while (right < sLen) {
      val sc = s.charAt(right)
      if (tArr(sc) > 0) {
        if (sArr(sc) < tArr(sc)) {
          distance += 1
        }
        sArr(sc) += 1

        while (distance == tLen) {
          val tempC = s.charAt(left)

          if (tArr(tempC) > 0) {
            if (tArr(tempC) == sArr(tempC)) {
              if (minLen > (right - left + 1)) {
                minLen = right - left + 1
                minStr = s.substring(left, right + 1)
              }
              distance -= 1
            }
            sArr(tempC) -= 1
          }
          left += 1
        }
        right += 1
      } else {
        right += 1
      }
    }
    minStr
  }

  /*
  78. 子集
给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
   */
  def subsets(nums: Array[Int]): List[List[Int]] = {
    val buffer: ListBuffer[List[Int]] = new ListBuffer[List[Int]]()
    backtrack(nums, buffer, new ListBuffer[Int](), 0)
    buffer.toList
  }

  def backtrack(nums: Array[Int], buffer: ListBuffer[List[Int]], list: ListBuffer[Int], start: Int): Unit = {
    buffer.append(list.toList)

    for (i <- start until nums.length) {
      list.append(nums(i))
      backtrack(nums, buffer, list, i + 1)
      list.remove(list.length - 1)

    }
  }

  /*
  79. 单词搜索
给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。



示例:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false


提示：

board 和 word 中只包含大写和小写英文字母。
1 <= board.length <= 200
1 <= board[i].length <= 200
1 <= word.length <= 10^3
   */
  def exist(board: Array[Array[Char]], word: String): Boolean = {
    if (board.isEmpty) {
      return false
    }
    val row = board.length
    val col = board(0).length
    val used: Array[Array[Boolean]] = Array.ofDim(row, col)

    for (i <- 0 until row; j <- 0 until col) {
      if (dfs(board, i, j, word, 0, used)) {
        return true
      }
    }
    false
  }

  def dfs(board: Array[Array[Char]], rowIdx: Int, colIdx: Int, word: String, idx: Int, used: Array[Array[Boolean]]): Boolean = {
    if (board(rowIdx)(colIdx) != word.charAt(idx)) {
      return false
    } else if (idx == word.length - 1) {
      return true
    }

    val direction: Array[(Int, Int)] = Array((0, 1), (0, -1), (-1, 0), (1, 0))
    used(rowIdx)(colIdx) = true

    for (tp <- direction) {
      val ri = rowIdx + tp._1
      val ci = colIdx + tp._2
      if (ri >= 0 && ri < board.length && ci >= 0 && ci < board(0).length && !used(ri)(ci)) {
        if (dfs(board, ri, ci, word, idx + 1, used)) {
          return true
        }
      }
    }
    used(rowIdx)(colIdx) = false
    false
  }

  /*
  84. 柱状图中最大的矩形
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。





以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。





图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。



示例:

输入: [2,1,5,6,2,3]
输出: 10
   */
  def largestRectangleArea(heights: Array[Int]): Int = {
    var len = heights.length
    if (len == 0)
      return 0
    if (len == 1)
      return heights(0)

    import scala.collection.mutable
    val stack: mutable.Stack[Int] = new mutable.Stack[Int]()
    var max = 0

    val newHeights = new Array[Int](len + 2)
    for (i <- 1 to len) {
      newHeights(i) = heights(i - 1)
    }
    len += 2

    stack.push(0)
    for (i <- 1 until len) {
      while (newHeights(stack.top) > newHeights(i)) {
        val popIdx = stack.pop
        val width = if (stack.isEmpty) i else (i - stack.top - 1)
        max = Math.max(max, newHeights(popIdx) * width)
      }
      stack.push(i)
    }
    max
  }

  /*
  85. 最大矩形
给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

示例:

输入:
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
输出: 6
   */
  def maximalRectangle(matrix: Array[Array[Char]]): Int = {
    if (matrix.isEmpty)
      return 0

    var maxArea = 0
    val dp: Array[Array[Int]] = Array.ofDim[Int](matrix.length, matrix(0).length)
    for (i <- 0 until matrix.length; j <- 0 until matrix(0).length) {
      if (matrix(i)(j) == '1') {
        dp(i)(j) = if (j == 0) 1 else dp(i)(j - 1) + 1
      }
      var width = dp(i)(j)
      for (k <- Range(i, -1, -1)) {
        width = Math.min(width, dp(k)(j))
        maxArea = Math.max(maxArea, width * (i - k + 1))
      }
    }
    maxArea
  }

  def maximalRectangle2(matrix: Array[Array[Char]]): Int = {
    if (matrix.isEmpty) {
      return 0
    }
    val heights: Array[Int] = new Array[Int](matrix(0).length)
    var max = 0
    for (i <- 0 until matrix.length) {
      for (j <- 0 until matrix(0).length) {
        if (matrix(i)(j) == '1') {
          heights(j) += 1
        } else {
          heights(j) = 0
        }
      }
      val temp = largestRectangleArea(heights)
      max = if (max < temp) temp else max
    }
    max
  }

  /*
      if (matrix.isEmpty)
      return 0

    var maxArea = 0
    val dp: Array[Array[Int]] = Array.ofDim[Int](matrix.length, matrix(0).length)
    for (i <- 0 until matrix.length; j <- 0 until matrix(0).length) {
      if (matrix(i)(j) == '1') {
        dp(i)(j) = if (j == 0) 1 else dp(i)(j - 1) + 1
      }
      var width = dp(i)(j)
      for (k <- Range(i, -1, -1)) {
        width = Math.min(width, dp(k)(j))
        maxArea = Math.max(maxArea, width * (i - k + 1))
      }
    }
    maxArea
   */

  class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
    var value: Int = _value
    var left: TreeNode = _left
    var right: TreeNode = _right

  }

  /*
  94. 二叉树的中序遍历
给定一个二叉树，返回它的中序 遍历。

示例:

输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？
   */
  def inorderTraversal(root: TreeNode): List[Int] = {
    import scala.collection.mutable
    import scala.collection.mutable.ListBuffer

    val buffer: ListBuffer[Int] = new ListBuffer[Int]()
    val stack = new mutable.Stack[TreeNode]()
    var curNode = root

    while (curNode != null || !stack.isEmpty) {
      if (curNode != null) {
        stack.push(curNode)
        curNode = curNode.left
      } else {
        curNode = stack.pop()
        buffer.append(curNode.value)
        curNode = curNode.right
      }
    }
    buffer.toList
  }

  def inorderTraversal2(root: TreeNode): List[Int] = {
    if (root == null)
      return List[Int]()

    val buffer: ListBuffer[Int] = new ListBuffer[Int]()
    rec(root, buffer)

    buffer.toList
  }

  def rec(root: TreeNode, buffer: ListBuffer[Int]): Unit = {
    if (root == null) {
      return
    }
    rec(root.left, buffer)
    buffer.append(root.value)
    rec(root.right, buffer)
  }

  /*
  96. 不同的二叉搜索树
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
   */

  def numTrees(n: Int): Int = {
    // 推导出的 G(n)函数的值在数学上被称为卡塔兰数
    val g: Array[Int] = new Array[Int](n + 1)
    g(0) = 1
    g(1) = 1
    for (i <- 2 to n) {
      for (j <- 1 to i) {
        g(i) += g(j - 1) * g(i - j)
      }
    }
    g(n)
  }

  def numTrees2(n: Int): Int = {
    var C: Long = 1
    for (i <- 0 until n) {
      C = C * 2 * (2 * i + 1) / (i + 2)
    }
    C.toInt
  }

  /*
  98. 验证二叉搜索树
给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
示例 1:

输入:
    2
   / \
  1   3
输出: true
示例 2:

输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
   */
  def isValidBST(root: TreeNode): Boolean = {
    import scala.collection.mutable
    var curNode = root
    val stack: mutable.Stack[TreeNode] = new mutable.Stack[TreeNode]()
    var inOrder: Double = Double.MinValue

    while (curNode != null || !stack.isEmpty) {
      while (curNode != null) {
        stack.push(curNode)
        curNode = curNode.left
      }

      curNode = stack.pop()
      if (curNode.value <= inOrder) {
        return false
      }
      inOrder = curNode.value
      curNode = curNode.right
    }
    true
  }

  /*
  101. 对称二叉树
给定一个二叉树，检查它是否是镜像对称的。



例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3


但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3


进阶：

你可以运用递归和迭代两种方法解决这个问题吗？
   */
  def isSymmetric(root: TreeNode): Boolean = {
    if (root == null) {
      return true
    }
    rec(root.left, root.right)

  }

  def rec(leftTree: TreeNode, rightTree: TreeNode): Boolean = {
    if (leftTree == null && rightTree == null) {
      true
    } else if (leftTree != null && rightTree != null) {
      if (leftTree.value == rightTree.value) {
        rec(leftTree.left, rightTree.right) && rec(leftTree.right, rightTree.left)
      } else {
        false
      }
    } else {
      false
    }
  }

  /*
  102. 二叉树的层序遍历
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。



示例：
二叉树：[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
   */
  def levelOrder(root: TreeNode): List[List[Int]] = {
    import scala.collection.mutable
    import scala.collection.mutable.ListBuffer
    val buffer: ListBuffer[List[Int]] = new ListBuffer[List[Int]]()
    val queue: mutable.Queue[TreeNode] = new mutable.Queue[TreeNode]()
    if (root != null) {
      queue.enqueue(root)
    }
    while (!queue.isEmpty) {
      val size = queue.size
      val temp = new ListBuffer[Int]()
      for (i <- 0 until size) {
        val node = queue.dequeue()
        temp.append(node.value)
        if (node.left != null) {
          queue.enqueue(node.left)
        }
        if (node.right != null) {
          queue.enqueue(node.right)
        }
      }
      buffer.append(temp.toList)
    }
    buffer.toList
  }

  /*
  104. 二叉树的最大深度
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。
   */
  def maxDepth(root: TreeNode): Int = {
    if (root == null) {
      0
    } else {
      Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
    }
  }

  def maxDepth2(root: TreeNode): Int = {
    if (root == null) {
      return 0
    }
    import scala.collection.mutable
    var curNode: TreeNode = null
    var maxLength = 0
    val queue: mutable.Queue[TreeNode] = new mutable.Queue[TreeNode]()
    queue.enqueue(root)
    while (!queue.isEmpty) {
      for (i <- 0 until queue.size) {
        curNode = queue.dequeue()
        if (curNode.left != null) {
          queue.enqueue(curNode.left)
        }
        if (curNode.right != null) {
          queue.enqueue(curNode.right)
        }
      }
      maxLength += 1
    }
    maxLength
  }


  /*
    105. 从前序与中序遍历序列构造二叉树
  根据一棵树的前序遍历与中序遍历构造二叉树。

  注意:
  你可以假设树中没有重复的元素。

  例如，给出

  前序遍历 preorder = [3,9,20,15,7]
  中序遍历 inorder = [9,3,15,20,7]
  返回如下的二叉树：

      3
     / \
    9  20
      /  \
     15   7
     */

  import scala.collection.mutable

  def buildTree(preorder: Array[Int], inorder: Array[Int]): TreeNode = {
    val n = preorder.length
    if (n == 0) {
      return null
    }
    if (n == 1) {
      return new TreeNode(preorder(0))
    }
    val map: mutable.Map[Int, Int] = mutable.Map[Int, Int]()
    for (i <- 0 until preorder.length) {
      map.put(inorder(i), i)
    }
    myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1, map)
  }

  def myBuildTree(preorder: Array[Int], inorder: Array[Int], pl: Int, pr: Int, il: Int, ir: Int, map: mutable.Map[Int, Int]): TreeNode = {
    if (pl > pr)
      return null

    val root = new TreeNode(preorder(pl))

    val rootIdx = map(preorder(pl))

    val sizeOfLeft = rootIdx - il

    root.left = myBuildTree(preorder, inorder, pl + 1, pl + sizeOfLeft, il, rootIdx - 1, map)

    root.right = myBuildTree(preorder, inorder, pl + sizeOfLeft + 1, pr, rootIdx + 1, ir, map)

    return root

  }

  /*
  114. 二叉树展开为链表
给定一个二叉树，原地将它展开为一个单链表。



例如，给定二叉树

    1
   / \
  2   5
 / \   \
3   4   6
将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
   */
  import scala.collection.mutable.ListBuffer
  def flatten(root: TreeNode): Unit = {
    val buffer: ListBuffer[TreeNode] = new ListBuffer[TreeNode]()
    var curNode = root
    preorderRec(root, buffer)
    for (i <- Range(1, buffer.length)) {
      curNode.left = null
      curNode.right = buffer(i)
      curNode = curNode.right
    }

  }

  def preorderRec(node: TreeNode, buffer: ListBuffer[TreeNode]): Unit = {
    if (node != null) {
      buffer.append(node)
      preorderRec(node.left, buffer)
      preorderRec(node.right, buffer)
    }
  }


}