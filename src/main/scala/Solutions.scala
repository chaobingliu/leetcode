
object Solutions {
  def main(args: Array[String]): Unit = {
    //    println("abc".last)
    //    val s = "abc"
    //    println(s.substring(0, s.length-1))
    //    println(isMatch("aab", "c*a**b")) // false
    //    println(isMatch("aa", "*a")) // false
    //    println(isMatch("aaa", "ab*a")) //false
    //    println(isMatch("aaa", "ab*a*c*a")) // true
    //    println(isMatch("aasdfasdfasdfasdfas", "aasdf.*asdf.*asdf.*asdf.*s")) // true
    //    println(isMatch("", "c*c*")) // true
    //    println(maxArea(Array(1, 8, 6, 2, 5, 4, 8, 3, 7)))
    //    println(letterCombinations("234"))
    //    val node1 = new ListNode(1)
    //    val node2 = new ListNode(2)
    //    val node3 = new ListNode(3)
    //    val node4 = new ListNode(4)
    //    val node5 = new ListNode(5)
    //    node1.next = node2
    //    node3.next = node4
    //    node4.next = node5
    //    var n = removeNthFromEnd(node1, 3)
    //    var n = mergeKLists(Array(node1, node3, node5))
    //    while (n != null) {
    //      println(n.x + " -> ")
    //      n = n.next
    //    }

    //    val arr = Array(-1, 0, 1, 2, -1, -4)
    //    val s = threeSum(arr)
    //    println(s)
    //    println(generateParenthesis(4))

    //    println(longestValidParentheses2(
    //      "((())))()())))(((()()(())))((()(())()((()))())())())()())))))))(((()(())(()))(()()(()()((()))()(())(()(())))))()(())(()()(((()(()()))))((()()))))))()((()())()()))((())()((((()))()()()((()())))())((())))))))(()()((((((()))(((((((()()))((())()(()())()()()(()())(()())(())))()()))))()(((())(())(()())()))()(()))(())((()))))(())))()))((()((()(())(()()()()()))(())())()))))()(()(((())))()()()(((()((()))(()((((((())((()))(()(())(()))(())())))()()))))())(()((()()())()))((((()(()))()()))(()())))((()))(()((((()(())(())()((()))(()))())))(((()(())))((())()(()(((())))())())()()()())((()()))))))(()))(())()(((()))()()((()))(()))(((()))))))))(()(())())(()((())(()()))((())))(()())((((())))(()(()))())(((()(()((()(())((())())(()))(())))()()(())((()()))((()()((()()())())()))())()))())()))())(()(()))(()))()(())))((((())()())()()())((()())(()())(()()))()(())(())))))()()()((()(())(((()(())()()))(()()((()(((()))))))))(((()((()()((()(((((())((()((()((((((((())()))())((())((()((()(()((())(((()(()))())))))))))))))()((()(())())))()(()))(((()))())()(((()))))((()(())(()())(((()(((()((((())()))))(())((()(((((()((()(()()()()((()((((((((((((())()(()))()()(()())()(()(((()((()(()()()())))((())()))())()()))())(((()(())))))()()()(((())))((()(()(((())(())(()((((()(((()(())(((((())()))())())()()(()())((((()(())))((()())))))))))()(()(())))))))()))()())))((())(()()()()()()()(())(()())))))())((()()))))()))))((())((()(((()))))(((()()))()(()((()()())()))(((()(()((())(()(()(()()))()((()(())))()((())))))(())()(())()))((())(((((()))()())(())))((((()((())())(())))(())))))((())())())((((()((())))()()((()()()))()())())(()())(((()))()()))))(()(())(()))()())(()())(()))(((((((()(()))())()())()())((()(((((()())(((())))()())))(()(()(())()((())()))(())))())()))((((()))())((()))(())))))(()))))))(()))))(())))())()()())()()(())()()(((((()))(((()()))()(()((((()(()(()(())))())))())(()()())()(()))())(()()))(()()((()()))))))(())((()()))(())))())())(())((((()))))()))()))()()()))))((((()((())(()))(()()))(())()())(()())))(()(()(())((()())()((())(()))()))()))))((())))(())(()))()()()()()))((())(((()(())))(((((((()(()))(()))())()((()))(()(())((()((()((())))()()((())))))((((())()())(()()(((()()((()))()()((())))(((()())((((()(())())))())()()()(())()))))))()()((()))())(()(((()()))((())))())())())((((()(((()(())())()())((()((()(()((())()(()))()((())))()(()))))(((()))())())(()((()))))()()(((((()))())))(()(()(())((((())())))((()()())(((((((()(()(()))(())))))()))(()(((((())()))((()()()()((()))()(()()()()))(()))))())())()))()(()()(((())((()))(()())))((()()(((())())))))))(())))((()(()(((())((((()))))(()()()))))(((((((())(()(()))(()(())((())(()(()(()(()())(())()(())(()()(()(()))())(())()()(((()())(())(()(((()()(())()((((()()))())(((()(((((()())()(())))()))))(()(()()(()(()()(((()))()))((()())))()(()(())))))))())((((()()))(()))))()((()))(()))())()))()))))(()(())()()()))(((((()))()())())(()())())))()())))))()()()())))))(())(((()))((())((()()))))()((((()(()(()))))(()(())(((())(()()(((()(())()())(()()(()(()())))()())))(((()()((()())()()((()))()))(((()((((()(((()(((()(()())((()))))()(()())(())()(()(((())((()))(())()(())()(()(())()))())()))()())(()))))()))))((()()()((()(()()(())))())(())()(()()))))))))()((()))((((())))())))((()()()(()(()((((()((()))()()((())((())(()))))(())())(((()()(()))))))(()()))()))((()(()(())()))(((())()))(())(()((((()((()()()))()()))(()()(())())((((((())(())((()())()(()())))()))())(()()(()(()()()(()()()()))(()(()()())())((()()()(((()((()())()()((()()(()((()())()())()((()))(()((()())))))))(())((((())(((((())(((())(()))(((()((()()())()((()(()))()()()(()((((())))(())())))((())))(()(((((()()()((())((((((((()()((((())))())())())))))))(((()())(((()))())))()))((())())())))))))))(()()(((())))))(())()()))((())()))(()(()))((()(()((((()(()(((()))))()))(()(()))())())()()(((())())(((()))))(((()())))()(()())()())()))())())(()()(((()()))(())(((()((())((((())))))((()))))(()((()(())))()(())((()(())((()(()())())))()))))(())())(()())()()()((())))((()()))()()()((((()())))))()))))()))())()((()(())()()(())(((()((()))(()(()()))(()))()))))))))))))(()()))(((())((()(((()()()(()())((((()(()()()))())))())(()())))(()((((()))((()()())(((()))()())(()(()((()(()))))(())()()((()())((()(()(()))((()((()())(((()(((((()()()))(()()(()(((()(()())()()()))((()(()())))())(()(()))(())()())))()()()))()())(()(((((()))()()((((()()()()))()()(()((()))(()))))))))))()))()(()((((((())(()))()((())))(((((())))))(()))))()()(()()()(((((()))()())()((((()()))()(())())))(((()((())))))))))(()()()((()))(()())((())))()()((()())))()()(()))))))))()(((()(()))()())((((((())))(((()(()())())))(())())())()()((((()(()(((())(()()(((((()))(()(())()))))))()))()())))()()(()))(((()))()())))((())(((()()))((((((())))(((())()()(()((()))())(()((()()(((())())()))()()())())(()()((((((((())))()(((())(()))))()()())()(())))(((((()())(((())()()))))()((())())(())()(()(()()((()))()(()(((()))))()()())(())()()()(((()((()()()(()())())(())()(((((()())(())()((((()()()))()((())()((()(()(((()(()))()())())()())()(()()(()(((()))()(())(()())(())((())()((()()())(()))))()(()()))))((())()()((()((()()(()((()()())(())))))())))()))))(((((()(()())(()))((()))()(()())())())))()(()()(()((())))))()()))((())((((()))))())((()))())((())((()(()((()))()()()))()((((((())((((((()((((((((()))(()(((()(((((((((())(())())()())))))))())())))()))(()))))()(()))(())))()()()((()()))(())(()))(()()(()())))()(()()()()())))(())((((()))(((((())(()(((((())((()((((()))(((((()))(()())()))))())()))()(()()))((((()))()())(())))()((())))(((((()()((()()((()))))()((())())()))(((((((((()((())((((())()())))(())())()))())))())()))()(()()(()))(()()()((())((()))())))()(()())()(((((((()))))(()()()((()(())))())()))((())())(()(()(())()()())))))(()()()))())()))()())(((())(())))()(())())))()((()(()(())()()()((()))()))((())((((()((((((()()()))()))())())))))()(())(()())))()(((()())(((())))((())()()))((())())()()(()()())()))())(((()((()(((()())(()(())(((())))()))))))())()((((((()))))))()(()))()))())))())((((())(())()(())()))()))((((((((()()(())())((((())))((((()(())()()(())()))())()))(((()((()))()(((((()()()))))(()(()())))(((()(((()(())())((((())(()((()((()(()()(()()))()))()()))()))))))())()(())())))(((())))((()))((()(())())((())))((()))()))(((()))))(()())()())())()())))())))(())))(())())()((()())()()))((()()())(((((()())))())))()()()((((((())())()((())()))(()))()(()())()())(())()())((()((())(())()()()()((())(()())()()((())))()(((()(()(((((()(())))()(()))()(()))()))())()))()())()(()))))()()())(((())((()((())(()(()))()((()))))))(())(()(())())()()((())((())((((())))))(()()())(()()())(())())(((()()(())(())))()()))(())))))())(())()(((())())))((()(((())))(()((())()))()))((()()())()(((((())((((())))(())()()((()()(()()))(()((()))((())())))))))()())))())())((()(()()()()()))))()))((())(((((()())(()))((())))((()(())))))))))(((())(()(())(()(())((()((()))()((())())()())()((()(())())()(((()()((()(()())))))())((())(((()())(((()(()((())((()(((())(()()((((((()))())))())(()(()(()()())())((()))((())(())(())())))()(()())()))())(())((((())()((())))))(()()((())(((((()))()()))()()())(()(((()))())()()()))(((()()))(()(()((())(())))()()((((()()))()(())()())()()()()()(()()))(((())(((()()()((((((((((()()()(((()))))))())))()(((((((()((((((((()))()(((())())())())((((((()()))(()))()))))(())()())))())(()))(((())()()()((()()((())(()))((()(()())))()(()((()((())()()()()(())()()((())())())()()))()()))))((()()((())(((())(())())))((())())())(()))))())))))()((()(()(()))))()))((((())((())())(()))))()((()))(())((()()))()()((())(())())))(())))))()()(()())((()(())(((()((())))()())))()))()))))(())()(()))((()()()()))(())))(()()(())(((()(((()()))()((()))())()))(()(()))())))))))()((()(()))(((())())(())(()))(())(()((()))))))(()())(()()()(((()(((((()))((()))))(()))(())())(((()(()())(()()()()))())(()((()(()))()))())))(((()(()))))()))(()()((())())(()()())((()))(())))()()))(())))())))(()((())((()))((()))))())()()()((((((())((())()))(()))(())(())())))()())()((())))((()()())(()))(((()))())())))(())(())())()())()))((((()()()()))(())))((((())))(())(()((((()))())()))))))()()()))())))()((())))))((())())))()()(()()(()(()()()())((((())))(())(((())(()(()((((())(()()()(()(()((())(())(()())((((()((()((((((()((((())(((()())()((((()((())()(()(()(()((()()()(()(()())(((()(())(()(())(())(()))()((((((((()()(())))(()()(((())()(()(((((()())((()(())()())(((()(()(())()((((((((())()((()()((((())(((()(()((()((((()((((()(()(())())()(((()()))))))(()(((())()(((()())))((()))))(()()))))(()))))))((())())((())))()()()(()((()))()))()))()()()()()))(((((((()((()))((())()(()(()))()((((((((((((()(())))))(()())))()(()()(()(()()))))(((((()()((())()))())()()()))(())())()())()()((()()(()(()()(()))))))()()))(()()((()))))()((()()()())))(((()(((()()(())(())(()(((())(()((()(()))(()()((())()(()()())()))))))(()()((())((()())))(())(()))()(()))(()))()))()(())()(()())))(()))(()()(((()))))())))))((())())))))()()()))(()))((()())())()()))(((())((()((())()(()))()((()))()(())))))))()()())())))(()()(())(()))(())))))()(()))(()()))))))))((((()()()()()))(()))((()((())))(()())(((()()()(())))))()))()())())(()()()))))))((()())))((())))(())()((()))()(()())())))))(((()()(()(())()())(((((()))((()(())(())))))))()()))))))((()((((()()))()))(()()))(()()(())))))(((()()))(()())))(())()((()((()(((()()()()((()())())(()(((((((()((((())(()((((()()(())))))(()())))))(()())))())(())))((()(()))(()())(((())))((((())))))((()))()(((((((())())())((())))))))(()))))))))()((()()())((())))(())))((()(((()(())(())))()()()()))(())(()(())()())(())))()())((()((()((()()((())())))(()((())()()))()))((()()(()))(((((((()))((())((())((())()()((((((((()())()()()))(()()(((()(())()))()))()))()()(()(((((()))))((())(((()))()((((((((()()()()(()))()(()))()(())))))))()((((()()((()(())()((()))((()()(()()))))))))))(())(()))()()((((())))()((())(()((()((()(())()))()()((((()))))()))())))))())(((()()))()))()(()))(()))()((()((((((())())))()))()((())(()(())))))))()))(()()()())())()))((()))(()((()((()())))))((((())()()())(())())()((()((()())()())()(()))))((()())))()))()()))))()((())))())(()))()))(()((())(()))))()()))(()()((((()()))(((()()())(()(()(((()))())))((((()())()()()(())()()()((()))))((()()(()()))()())))(((((()(())())))))(()))))())))(())())()))))((()))))))(((())(((())()(((())))(()))()())(((()(()(((()))))()(()()(())())))))())())()()((())))()(())((()))((())(()())(()()()(()()())((())())))))((()(()())()()))))(()()(()()()(()()))((((((()))(()())(())(())())((())(()(()))((()()(()))))()))()(())))())))())(()((())))((())(()()()(()))((()((((((()())()()))))()))((()((())()))()((((()()()(((())())))()()()())())())(()())()))()(())(())()))())((()(((((()))(())(((((()))(()())(()(()(())()((()(()(()))()(()))))()(((())(()((((((()))(()(((()()())()())((()())))((()((()())()((((((())()))(()))))(()()()()))())())((((((((())((((()()()))(())()()))(()(()()(()(()))))(()))(()()()(())()()(())(()))())((()()((()(()))()))))())((()())())(((((()(()()))((()()()))()()(()(()(((()())(((((((((()))()())(()(()(())(((((()()))))(()())(()())())(())))))((()))())(((()((((()))()))(()(()(((()()(()(((()()))(())))((((()(()()))))((((()()())()))())()))))((())((((((())()()))()))()(((()((())(()((((()())())((((((((((()(((((()())()()(()))))))()((((())())(((()()((((()()())()(((((())))()))(())())(((()(((())()))()()()()(())))(()(((()(()))())))()(((()()()()()(()(((()(((()))()(())(())()()))()((()))))))()(((((()(()()((())(())((())))()(()())(())))())((())(()(()()(((())((()()(()()((()))))())))()(()))()))))))())())))((((((()())))(())(()))()()))()(())))))))((()))(()()()()))()())()()()()))()()())))))))((())(())))(()))(())((()())))(()(((()))((((())())))(())((())())))))(((()())(())()(())))((()()()((()(()))()))(())))((()(()()((()()()))((()))((()))()))(()())()()(((((((((()(()))()())()((())((((((((()(())()(((()((())()((((((((()))())))(()((()((())())())((()()())))(()(()((((((()))))((((())))((()()(())()())()()())(())(((()(()()(())(((())((((())()()(()()(((())()(())((()(()(((()(()())))()))((()()())(())))))(()(()))()))()(()))))(()((()))()())(())(())(()))((()())()))())()())((((()))))())())(((()))(((()()((()((())(())()()))))(((()((((()(((((((((())()()()(())((()(()()(()()(()()(())()())(((((()))))()(())(((()((((()())(()(((()))))()))())((((()()((()(()))))((())(())(()(()))()()(((()))(((((((((()())))((())()(()(((((((()))))))()()(())(((()(()())()()))((()()))((((()(())())))((()())))))()))))))))()()(((())())((()))())((())((()()))())((((((((())((()((())())))))()()))))))()()(())))))()))()()(((()))))(())((((()()()()))((()((((()()(())(((((()())()))))))())())()((((((((((()))()))((()))(())())(()(()(())((()()(()((())(())((((())(()()(()((()((()(((((()(()()((((())(())())(()()())()())((()(())()(())()))))"))

    //    println(longestValidParentheses2(""))
    //        val arr = Array(5, 4, 7, 5, 3, 2) // 5,5,2,3,4,7
    //        val arr = Array(1, 2, 3) // 1, 3, 2
    //    val arr = Array(1, 3, 2) // 2, 1, 3
    //    val arr = Array(2, 1, 3) // 2,3,1
    val arr = Array(2, 2, 7, 5, 4, 3, 2, 2, 1)
    println("before: " + arr.mkString(","))
    nextPermutation(arr)
    println("after: " + arr.mkString(","))
  }

  /*
1. 两数之和
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。



示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
 */
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    for (i <- 0 until nums.length; j <- i + 1 until nums.length) {
      if (nums(i) + nums(j) == target) {
        return Array(i, j)
      }
    }
    Array[Int]()
  }

  class ListNode(_x: Int = 0, _next: ListNode = null) {
    var next: ListNode = _next
    var x: Int = _x
  }

  /*
  2. 两数相加
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
   */
  def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {
    var node1 = l1
    var node2 = l2
    var retNode: ListNode = null
    var curNode: ListNode = null
    var carry: Int = 0

    while (node1 != null || node2 != null) {
      if (retNode == null) {
        curNode = new ListNode
        retNode = curNode
      } else {
        curNode.next = new ListNode()
        curNode = curNode.next
      }

      val x1 = if (node1 == null) 0 else node1.x
      val x2 = if (node2 == null) 0 else node2.x
      val sum = x1 + x2 + carry
      if (sum / 10 > 0) {
        carry = sum / 10
        curNode.x = sum % 10
      } else {
        carry = 0
        curNode.x = sum
      }
      node1 = if (node1 == null) null else node1.next
      node2 = if (node2 == null) null else node2.next
    }
    if (carry > 0) {
      curNode.next = new ListNode(carry)
    }
    retNode
  }

  /*
  3. 无重复字符的最长子串
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
   */
  def lengthOfLongestSubstring(s: String): Int = {
    if (s.length == 1)
      return 1
    var latestLen = 0
    import scala.util.control.Breaks
    val loop = new Breaks
    for (i <- 0 until s.length) {
      loop.breakable {
        for (j <- i + latestLen until s.length) {
          val curStr = s.substring(i, j + 1)
          if (curStr.length > latestLen && curStr.length == curStr.distinct.length) {
            latestLen = curStr.length
          } else {
            loop.break()
          }
        }
      }
    }
    //    println(latestStr)
    latestLen
  }

  /*
  4. 寻找两个正序数组的中位数
给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。

进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？



示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
示例 2：

输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
示例 3：

输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
示例 4：

输入：nums1 = [], nums2 = [1]
输出：1.00000
示例 5：

输入：nums1 = [2], nums2 = []
输出：2.00000


提示：

nums1.length == m
nums2.length == n
0 <= m <= 1000
0 <= n <= 1000
1 <= m + n <= 2000
-106 <= nums1[i], nums2[i] <= 106

   */
  def findMedianSortedArrays(nums1: Array[Int], nums2: Array[Int]): Double = {
    val len = nums1.length + nums2.length
    val intArr: Array[Int] = new Array[Int](len)
    var i1: Int = 0
    var i2: Int = 0
    for (j <- 0 until intArr.length) {
      val num1: Int = if (i1 < nums1.length) nums1(i1) else Int.MaxValue
      val num2: Int = if (i2 < nums2.length) nums2(i2) else Int.MaxValue
      if (num1 < num2) {
        intArr(j) = num1
        i1 += 1
      } else {
        intArr(j) = num2
        i2 += 1
      }
    }

    if (len % 2 == 1) {
      return intArr(len / 2)
    } else {
      val m = len / 2
      return (intArr(m - 1) + intArr(m)) / 2.0
    }
  }

  /*
  5. 最长回文子串
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"
   */
  def longestPalindrome(s: String): String = {
    var latestLength = 0
    var latestStr = ""

    for (i <- 0 until s.length) {
      for (j <- i + latestLength until s.length) {
        val curStr = s.substring(i, j + 1)
        if (isPalindrome(curStr)) {
          if (curStr.length > latestLength) {
            latestStr = curStr
            latestLength = curStr.length
          }
        }
      }
    }
    latestStr
  }

  def isPalindrome(s: String): Boolean = {
    for (i <- 0 until s.length) {
      if (i >= s.length - i - 1) {
        return true
      }
      if (s.charAt(i) != s.charAt(s.length - i - 1)) {
        return false
      }
    }
    return false
  }

  /*
  10. 正则表达式匹配
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
示例 1:

输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
示例 2:

输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
示例 3:

输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
示例 4:

输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
示例 5:

输入:
s = "mississippi"
p = "mis*is*p*."
输出: false

   */
  def isMatch(s: String, p: String): Boolean = {
    if (s == p || p == ".*" || (p == "." && s.length == 1) || (s.isEmpty && (p.length == 2 && p.last == '*')) || s + "*" == p) {
      return true
    }
    if (p.isEmpty || (s.length == 1 && p.length == 1)) {
      return false
    } else if (s.isEmpty) {
      if (p.last == '*' && p.length > 1) {
        return isMatch(s, p.substring(0, p.length - 2))
      } else {
        return false
      }
    }
    val pl = p.last
    val sl = s.last

    if (sl == pl || pl == '.') {
      return isMatch(s.substring(0, s.length - 1), p.substring(0, p.length - 1))
    } else if (pl == '*') {
      val preChar: Char = p.charAt(p.length - 2)
      // 当P为*时，S可能匹配一次，匹配0次，匹配多次
      // isMatch(s, p.substring(0, p.length - 2)) 匹配0次
      // isMatch(s.substring(0, s.length-1), p.substring(0, p.length-2)) 匹配1次
      // isMatch(s.substring(0, s.length - 1), p) 匹配多次
      if (preChar == sl || preChar == '.') {
        return isMatch(s, p.substring(0, p.length - 2)) || isMatch(s.substring(0, s.length - 1), p.substring(0, p.length - 2)) || isMatch(s.substring(0, s.length - 1), p)
      } else {
        return isMatch(s, p.substring(0, p.length - 2))
      }
    }
    else {
      false
    }
  }

  /*
  给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。

 



图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

 

示例：

输入：[1,8,6,2,5,4,8,3,7]
输出：49

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/container-with-most-water
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
   */
  def maxArea(height: Array[Int]): Int = {
    var head = 0
    var tail = height.length - 1
    var maxA = 0
    while (head < tail) {
      if (height(head) < height(tail)) {
        maxA = Math.max(height(head) * (tail - head), maxA)
        head += 1
      } else {
        maxA = Math.max(height(tail) * (tail - head), maxA)
        tail -= 1
      }
    }
    maxA
  }

  /*
  15. 三数之和
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。



示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
0 = -4
1 = -1
2 = -1
3 = 0
4 = 1
5 = 2

   */
  def threeSum(nums: Array[Int]): List[List[Int]] = {
    import scala.collection.mutable.ListBuffer
    import scala.util.control.Breaks
    val buffer: ListBuffer[List[Int]] = new ListBuffer[List[Int]]()
    val newNums = nums.sorted
    val loop = new Breaks
    for (i <- 0 until newNums.length) {
      if (i == 0 || newNums(i) != newNums(i - 1)) {
        for (j <- i + 1 until newNums.length) {
          if (j == (i + 1) || newNums(j) != newNums(j - 1)) {
            loop.breakable {
              for (k <- Range(newNums.length - 1, j, -1)) {
                val temp = newNums(i) + newNums(j) + newNums(k)
                if (temp < 0) {
                  loop.break()
                }
                if (temp == 0) {
                  buffer.append(List(newNums(i), newNums(j), newNums(k)))
                  loop.break()
                }
              }
            }
          }
        }
      }
    }
    buffer.toList
  }

  /*
  17. 电话号码的字母组合
  给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

  给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。



  示例:

  输入："23"
  输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
  说明:
  尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。
   */
  def letterCombinations(digits: String): List[String] = {
    import scala.collection.mutable.ListBuffer
    val maps = Map[Char, Array[String]](
      '1' -> Array[String]("!", "@", "#"), '2' -> Array[String]("a", "b", "c"), '3' -> Array[String]("d", "e", "f"),
      '4' -> Array[String]("g", "h", "i"), '5' -> Array[String]("j", "k", "l"), '6' -> Array[String]("m", "n", "o"),
      '7' -> Array[String]("p", "q", "r", "s"), '8' -> Array[String]("t", "u", "v"), '9' -> Array[String]("w", "x", "y", "z")
    )

    if (digits.isEmpty) return List[String]()
    var buffer: ListBuffer[Array[String]] = new ListBuffer[Array[String]]()

    for (c <- digits) {
      buffer.append(maps(c))
    }

    return buffer.reduce((A, B) => {
      for (a <- A; b <- B) yield {
        a + b
      }
    }).toList
  }

  /*
  19. 删除链表的倒数第N个节点
  给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

  示例：

  给定一个链表: 1->2->3->4->5, 和 n = 2.

  当删除了倒数第二个节点后，链表变为 1->2->3->5.
  说明：

  给定的 n 保证是有效的。

  进阶：

  你能尝试使用一趟扫描实现吗？
   */
  def removeNthFromEnd(head: ListNode, n: Int): ListNode = {
    import scala.collection.mutable.ListBuffer
    var node = head
    var buffer: ListBuffer[ListNode] = new ListBuffer[ListNode]()

    while (node != null) {
      buffer.append(node)
      node = node.next
    }
    if (buffer.size == 1 && n == 1) {
      return null
    } else if (buffer.size == 2) {
      if (n == 2) {
        buffer(0).next = null
        return buffer(1)
      } else {
        buffer(0).next = null
        return buffer(0)
      }
    } else {
      if (n == 1) {
        buffer(buffer.size - 2).next = null
      } else if (n == buffer.size) {
        head.next = null
        return buffer(1)
      } else {
        val preNode = buffer(buffer.size - n - 1)
        val nextNode = buffer(buffer.size - n + 1)
        preNode.next = nextNode
      }
      head
    }
  }

  /*
 20. 有效的括号
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

示例 1:

输入: "()"
输出: true
示例 2:

输入: "()[]{}"
输出: true
示例 3:

输入: "(]"
输出: false
示例 4:

输入: "([)]"
输出: false
示例 5:

输入: "{[]}"
输出: true
   */

  def isValid(s: String): Boolean = {
    import scala.collection.mutable
    val map = Map((')', '('), (']', '['), ('}', '{'))
    var stack = mutable.Stack[Char]()
    for (c <- s) {
      if (stack.isEmpty) {
        stack.push(c)
      } else {
        if (stack.top == map.getOrElse(c, '_')) {
          stack.pop()
        } else {
          stack.push(c)
        }
      }
    }
    stack.isEmpty
  }

  /*
  21. 合并两个有序链表
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。



示例：

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
   */
  def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
    var node1 = l1
    var node2 = l2
    var retNode: ListNode = null
    var retCurNode: ListNode = null

    if (node1 == null) {
      node2
    } else if (node2 == null) {
      node1
    } else {
      while (node1 != null && node2 != null) {
        if (retNode == null) {
          retNode = new ListNode()
          retCurNode = retNode
        } else {
          retCurNode.next = new ListNode()
          retCurNode = retCurNode.next
        }
        if (node1.x < node2.x) {
          retCurNode.x = node1.x
          node1 = node1.next
        } else {
          retCurNode.x = node2.x
          node2 = node2.next
        }
      }
      if (node1 != null)
        retCurNode.next = node1
      if (node2 != null)
        retCurNode.next = node2
      retNode
    }
  }

  /*
  22. 括号生成
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。



示例：

输入：n = 3
输出：[
       "((()))",
       "(()())",
       "(())()",
       "()(())",
       "()()()"
     ]
   */
  def generateParenthesis(n: Int): List[String] = {
    if (n == 0) {
      List[String]()
    } else {
      import scala.collection.mutable.ListBuffer
      var arr = new Array[ListBuffer[String]](n)
      arr(0) = ListBuffer("()")
      for (i <- 1 until n) {
        var buffer = new ListBuffer[String]()
        buffer.append(arr(i - 1)(0) + "()")
        val preList = arr(i - 1)
        for (str <- preList) {
          for (j <- 0 until str.length) {
            if (str.charAt(j) == ')') {
              var temp = str.substring(0, j) + "()" + str.substring(j)
              if (!buffer.contains(temp)) {
                buffer.append(temp)
              }
            }
          }
        }
        arr(i) = buffer
      }
      arr(n - 1).toList
    }
  }

  /*
  23. 合并K个升序链表
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。



示例 1：

输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
示例 2：

输入：lists = []
输出：[]
示例 3：

输入：lists = [[]]
输出：[]


提示：

k == lists.length
0 <= k <= 10^4
0 <= lists[i].length <= 500
-10^4 <= lists[i][j] <= 10^4
lists[i] 按 升序 排列
lists[i].length 的总和不超过 10^4
   */
  def mergeKLists(lists: Array[ListNode]): ListNode = {
    if (lists.isEmpty || (lists.length == 1 && lists(0) == null))
      return null
    return lists.reduce(mergeTwoLists)
  }

  /*
  31. 下一个排列
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

   */
  def nextPermutation(nums: Array[Int]): Unit = {
    if (nums.isEmpty)
      return
    for (i <- Range(nums.length - 1, -1, -1); if (i - 1) >= 0) {
      if (nums(i - 1) < nums(i)) {
        if (i == nums.length - 1) {
          val temp = nums(i - 1)
          nums(i - 1) = nums(i)
          nums(i) = temp
          return
        }
        for (j <- i until nums.length) {
          if (j == nums.length - 1 || nums(i - 1) >= nums(j + 1)) {
            val temp = nums(i - 1)
            nums(i - 1) = nums(j)
            nums(j) = temp
            // 调换顺序后正序排序
            var mh = i
            var mt = nums.length - 1
            while (mh < mt) {
              val t = nums(mh)
              nums(mh) = nums(mt)
              nums(mt) = t
              mh += 1
              mt -= 1
            }
            return
          }
        }
      }
    }
    var head = 0
    var tail = nums.length - 1
    while (head < tail) {
      var temp = nums(head)
      nums(head) = nums(tail)
      nums(tail) = temp
      head += 1
      tail -= 1
    }
  }

  /*
  32. 最长有效括号
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:

输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
示例 2:

输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
   */
  // 动态规划法 ，推荐使用
  // 动态转移方程： dp(i) = dp(i-1) + dp(i-di(i-1)-1-1) + 2
  // 该方程的使用条件： 当dp(i)为 ')' 时，判断 dp(i-dp(i-1)-1)的位置是否为'('
  // 同时还需要考虑dp(i-dp(i-1)-1-1 前的最长有效子串
  def longestValidParentheses(s: String): Int = {
    if (s.isEmpty)
      return 0
    val dp: Array[Int] = new Array[Int](s.length)
    for (i <- 1 until dp.length) {
      if (s.charAt(i) == ')') {
        val t = i - dp(i - 1) - 1
        if (t >= 0 && s.charAt(t) == '(') {
          if (t - 1 >= 0) {
            dp(i) = dp(i - 1) + 2 + dp(t - 1)
          } else {
            dp(i) = dp(i - 1) + 2
          }
        }
      }
    }
    dp.max
  }

  // 最传统的方法，效率极差，非常不推荐使用
  def longestValidParentheses2(s: String): Int = {
    import scala.util.control.Breaks
    var maxValid = 0
    val loop = new Breaks
    for (i <- 0 until s.length; if (s.charAt(i) == '(')) {
      if (maxValid >= s.length - i) {
        return maxValid
      }
      loop.breakable {
        for (j <- Range(s.length, i, -1); if (s.charAt(j - 1) == ')' && (j - i) % 2 == 0)) {
          if (maxValid < j - i) {
            if (isValid2(s.substring(i, j))) {
              maxValid = if (maxValid < j - i - 1) j - i else maxValid
              loop.break()
            }
          } else {
            loop.break()
          }
        }
      }
    }
    maxValid
  }

  def isValid2(s: String): Boolean = {
    if (s.length % 2 == 1) {
      return false
    }
    import scala.collection.mutable
    val map = Map((')', '('), (']', '['), ('}', '{'))
    var stack = mutable.Stack[Char]()
    for (c <- s) {
      if (stack.isEmpty) {
        if (map.keySet.contains(c))
          return false
        stack.push(c)
      } else {
        if (stack.top == map.getOrElse(c, '_')) {
          stack.pop()
        } else {
          stack.push(c)
        }
      }
    }
    stack.isEmpty
  }
}